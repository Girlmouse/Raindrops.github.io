<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Raindrops — A moment in time</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;}
body{background:#040a14;display:flex;flex-direction:column;align-items:center;justify-content:center;
min-height:100vh;min-height:100dvh;font-family:'Helvetica Neue',-apple-system,sans-serif;
user-select:none;-webkit-user-select:none;touch-action:none;overflow:hidden;}
canvas{border-radius:12px;cursor:pointer;touch-action:none;box-shadow:0 0 60px rgba(80,160,220,0.06);}
.sub{color:rgba(255,255,255,0.25);font-size:12px;margin-top:10px;letter-spacing:2px;text-align:center;}
</style>
</head>
<body>
<canvas id="g"></canvas>
<p class="sub">RAINDROPS — A moment in time</p>
<script>
// === CONFIG ===
const DROPS_TO_WIN = 30;
const RAIN_INT = 40; // faster spawn for misty rain
const GLOW_MIN_GAP = 1000;
const GLOW_MAX_GAP = 2000;
const HIT_R = 45;
const DURATION = 240;
const DENSE = 10; // more drops for misty effect

const QUOTES = [
  "The ocean has no memory of the storm.",
  "Waves don't count their journeys to shore.",
  "Between the tides, there is stillness.",
  "The sea was here before your worry. It will be here after.",
  "Breathe in salt. Breathe out everything else.",
  "Even the deepest waters start with a single drop.",
  "The horizon is patient. So can you be.",
  "Let the current carry what you no longer need.",
  "The shore remembers every wave, and forgives them all.",
  "You are not the storm. You are the sea beneath it.",
];

// === AUDIO ===
let actx=null,started=false,rainSrc=null,rainG=null;

function initAudio(){
  if(started)return;try{
  actx=new(window.AudioContext||window.webkitAudioContext)();started=true;
  const sr=actx.sampleRate,len=sr*3;
  // Layer 1: Ocean rain (brown noise, warm)
  const buf1=actx.createBuffer(2,len,sr);
  for(let ch=0;ch<2;ch++){const d=buf1.getChannelData(ch);let last=0;
    for(let i=0;i<len;i++){const w=Math.random()*2-1;d[i]=(last+(0.02*w))/1.02;last=d[i];d[i]*=3.5;}}
  const src1=actx.createBufferSource();src1.buffer=buf1;src1.loop=true;
  const f1=actx.createBiquadFilter();f1.type="lowpass";f1.frequency.value=1500;
  const g1=actx.createGain();g1.gain.value=0.12;
  src1.connect(f1);f1.connect(g1);src1.start();
  // Layer 2: Wave-like swell (slow modulated noise)
  const buf2=actx.createBuffer(2,len,sr);
  for(let ch=0;ch<2;ch++){const d=buf2.getChannelData(ch);
    for(let i=0;i<len;i++){const env=0.3+0.7*Math.sin(i/sr*0.4*Math.PI*2);d[i]=(Math.random()*2-1)*env;}}
  const src2=actx.createBufferSource();src2.buffer=buf2;src2.loop=true;
  const f2=actx.createBiquadFilter();f2.type="lowpass";f2.frequency.value=500;
  const g2=actx.createGain();g2.gain.value=0.06;
  src2.connect(f2);f2.connect(g2);src2.start();
  // Layer 3: Rain on water patter
  const buf3=actx.createBuffer(1,len,sr);
  const d3=buf3.getChannelData(0);
  for(let i=0;i<len;i++){d3[i]=Math.random()>0.99?(Math.random()*2-1)*0.35:0;}
  const src3=actx.createBufferSource();src3.buffer=buf3;src3.loop=true;
  const f3=actx.createBiquadFilter();f3.type="bandpass";f3.frequency.value=3000;f3.Q.value=0.6;
  const g3=actx.createGain();g3.gain.value=0.05;
  src3.connect(f3);f3.connect(g3);src3.start();
  // Master
  rainG=actx.createGain();rainG.gain.value=1.0;
  g1.connect(rainG);g2.connect(rainG);g3.connect(rainG);
  rainG.connect(actx.destination);
  rainSrc=src1;
  }catch(e){}}

// Soft string pluck / kalimba
function chime(){
  if(!actx)return;
  const notes=[440,523.2,587.3,659.2,784,880,1046.5];
  const f=notes[Math.floor(Math.random()*notes.length)];
  // Plucked string
  const o=actx.createOscillator(),g=actx.createGain();
  o.type="triangle";o.frequency.value=f;
  g.gain.setValueAtTime(0.15,actx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.03,actx.currentTime+0.3);
  g.gain.exponentialRampToValueAtTime(0.001,actx.currentTime+0.8);
  o.connect(g);g.connect(actx.destination);o.start();o.stop(actx.currentTime+0.8);
  // Soft body resonance
  const o2=actx.createOscillator(),g2=actx.createGain();
  o2.type="sine";o2.frequency.value=f*0.5;
  g2.gain.setValueAtTime(0.06,actx.currentTime);
  g2.gain.exponentialRampToValueAtTime(0.001,actx.currentTime+0.5);
  o2.connect(g2);g2.connect(actx.destination);o2.start();o2.stop(actx.currentTime+0.5);
}

function playEnd(){
  if(!actx)return;
  if(rainG)rainG.gain.linearRampToValueAtTime(0.05,actx.currentTime+4);
  [261.6,329.6,392,523.2].forEach((f,i)=>{
    const o=actx.createOscillator(),g=actx.createGain();
    o.type="triangle";o.frequency.value=f;
    g.gain.setValueAtTime(0,actx.currentTime+i*0.3);
    g.gain.linearRampToValueAtTime(0.05,actx.currentTime+i*0.3+0.6);
    g.gain.exponentialRampToValueAtTime(0.001,actx.currentTime+i*0.3+4);
    o.connect(g);g.connect(actx.destination);o.start(actx.currentTime+i*0.3);o.stop(actx.currentTime+i*0.3+4);
  });
}

function resetRain(){if(rainG&&actx)rainG.gain.linearRampToValueAtTime(1.0,actx.currentTime+1);}

// === CANVAS (4:3 like mountain scene) ===
const cv=document.getElementById("g"),c=cv.getContext("2d");
function getSize(){
  const mw=Math.min(window.innerWidth*0.98,800);
  const mh=(window.innerHeight||document.documentElement.clientHeight)*0.88;
  let w=mw,h=w/(4/3);if(h>mh){h=mh;w=h*(4/3);}if(w>mw){w=mw;h=w/(4/3);}
  return{w:Math.floor(w),h:Math.floor(h)};
}
function resize(){const{w,h}=getSize();cv.width=w*2;cv.height=h*2;cv.style.width=w+"px";cv.style.height=h+"px";c.setTransform(2,0,0,2,0,0);}
resize();window.addEventListener("resize",resize);

// === OCEAN & BUOY ===
let waveOffset=0;
let buoyBlinkPhase=0;

function drawOcean(w,h,t){
  const horizonY=h*0.55;

  // Ocean body - darker bottom 1/3 (deep water)
  const oceanGrad=c.createLinearGradient(0,horizonY,0,h);
  oceanGrad.addColorStop(0,"rgba(35,55,80,0.9)");
  oceanGrad.addColorStop(0.3,"rgba(25,42,65,0.95)");
  oceanGrad.addColorStop(0.5,"rgba(15,28,45,0.97)");
  oceanGrad.addColorStop(0.67,"rgba(8,16,28,0.98)");
  oceanGrad.addColorStop(1,"rgba(3,8,15,1)");
  c.fillStyle=oceanGrad;
  c.fillRect(0,horizonY,w,h-horizonY);

  // Horizon line glow - DRAW FIRST so boat/buoy appear in front
  const horizonGlow = c.createLinearGradient(0, horizonY-12, 0, horizonY+12);
  horizonGlow.addColorStop(0, "rgba(100,140,180,0)");
  horizonGlow.addColorStop(0.35, "rgba(130,170,210,0.12)");
  horizonGlow.addColorStop(0.5, "rgba(160,200,240,0.35)");
  horizonGlow.addColorStop(0.65, "rgba(130,170,210,0.12)");
  horizonGlow.addColorStop(1, "rgba(100,140,180,0)");
  c.fillStyle = horizonGlow;
  c.fillRect(0, horizonY-12, w, 24);
  
  // Thin bright line at horizon
  c.strokeStyle="rgba(180,215,250,0.4)";
  c.lineWidth=1.5;
  c.beginPath();c.moveTo(0,horizonY);c.lineTo(w,horizonY);c.stroke();

  // Waves - more animated
  waveOffset+=0.018;
  
  // Main wave layers
  for(let layer=0;layer<5;layer++){
    const waveY=horizonY+6+layer*16;
    const amp=2+layer*1.8;
    const freq=0.014-layer*0.002;
    const speed=waveOffset*(1.2-layer*0.15);
    const alpha=0.10-layer*0.018;

    c.strokeStyle=`rgba(100,145,190,${alpha})`;
    c.lineWidth=1;
    c.beginPath();
    for(let x=0;x<w;x+=2){
      const y=waveY+Math.sin(x*freq+speed)*amp+Math.sin(x*freq*2.3+speed*1.5)*amp*0.4+Math.sin(x*freq*0.7-speed*0.8)*amp*0.2;
      if(x===0)c.moveTo(x,y);else c.lineTo(x,y);
    }
    c.stroke();
  }
  
  // Subtle shimmer/light reflections on water
  c.save();
  for(let i=0;i<12;i++){
    const shimmerX = (w*0.1 + i*w*0.07 + Math.sin(waveOffset*0.5+i)*15) % w;
    const shimmerY = horizonY + 20 + i*12 + Math.sin(waveOffset+i*2)*3;
    const shimmerAlpha = 0.04 + Math.sin(waveOffset*1.5+i*1.3)*0.02;
    c.fillStyle=`rgba(140,180,220,${shimmerAlpha})`;
    c.beginPath();
    c.ellipse(shimmerX, shimmerY, 8+Math.sin(waveOffset+i)*3, 2, 0, 0, Math.PI*2);
    c.fill();
  }
  c.restore();

  // Distant yacht silhouette (left side) - below horizon line
  const boatX = w*0.22;
  const boatY = horizonY + 20;
  c.fillStyle="rgba(20,25,35,0.9)";
  // Hull - sleek yacht shape
  c.beginPath();
  c.moveTo(boatX-24, boatY+2);
  c.quadraticCurveTo(boatX-27, boatY+6, boatX-20, boatY+8);
  c.lineTo(boatX+24, boatY+8);
  c.quadraticCurveTo(boatX+30, boatY+5, boatX+27, boatY+2);
  c.lineTo(boatX-24, boatY+2);
  c.closePath();
  c.fill();
  // Cabin/superstructure
  c.fillStyle="rgba(25,30,42,0.9)";
  c.beginPath();
  c.moveTo(boatX-10, boatY+2);
  c.lineTo(boatX-8, boatY-6);
  c.lineTo(boatX+14, boatY-6);
  c.lineTo(boatX+16, boatY+2);
  c.closePath();
  c.fill();
  // Upper deck
  c.fillStyle="rgba(22,27,38,0.9)";
  c.beginPath();
  c.moveTo(boatX-5, boatY-6);
  c.lineTo(boatX-3, boatY-11);
  c.lineTo(boatX+8, boatY-11);
  c.lineTo(boatX+10, boatY-6);
  c.closePath();
  c.fill();
  // Small mast/antenna
  c.fillRect(boatX+2, boatY-16, 1.5, 6);

  // Buoy (right side, floating on water) - below horizon line
  const buoyX = w*0.78;
  const buoyY = horizonY + 28;
  const bobOffset = Math.sin(t*0.002)*2;
  
  // Buoy body
  c.fillStyle="rgba(20,25,35,0.9)";
  c.beginPath();
  c.ellipse(buoyX, buoyY + bobOffset, 8, 12, 0, 0, Math.PI*2);
  c.fill();
  
  // Buoy top structure
  c.fillStyle="rgba(25,30,40,0.9)";
  c.fillRect(buoyX-2, buoyY - 18 + bobOffset, 4, 10);
  
  // Blinking light - slow blink (on for 2 sec, off for 2 sec)
  buoyBlinkPhase = t * 0.001;
  const blinkOn = Math.sin(buoyBlinkPhase) > 0;
  
  if(blinkOn){
    // Light glow
    const lg=c.createRadialGradient(buoyX, buoyY - 20 + bobOffset, 0, buoyX, buoyY - 20 + bobOffset, 20);
    lg.addColorStop(0,"rgba(255,80,80,0.4)");
    lg.addColorStop(0.5,"rgba(255,60,60,0.15)");
    lg.addColorStop(1,"rgba(255,50,50,0)");
    c.fillStyle=lg;
    c.beginPath();
    c.arc(buoyX, buoyY - 20 + bobOffset, 20, 0, Math.PI*2);
    c.fill();
    // Light center
    c.fillStyle="rgba(255,100,100,0.9)";
    c.beginPath();
    c.arc(buoyX, buoyY - 20 + bobOffset, 3, 0, Math.PI*2);
    c.fill();
  }
}

// === GAME STATE ===
const gs={
  drops:[],catchPs:[],ripples:[],
  score:0,phase:"menu",timeLeft:DURATION,
  lastRain:0,nextGlow:0,
  cloudOff:0,menuPulse:0,
  endT:0,endQuote:"",
  dimAlpha:0,rainFaded:false,rbPs:null,
};

// Guardrails for glowing drops - keep centered
const GLOW_MARGIN = 0.15;

function scheduleGlow(){
  gs.nextGlow=Date.now()+GLOW_MIN_GAP+Math.random()*(GLOW_MAX_GAP-GLOW_MIN_GAP);
}

function mkDrop(w,h,forceGlow){
  const gl=forceGlow||false;
  // Glowing drops stay centered
  const xPos = gl 
    ? w*GLOW_MARGIN + Math.random()*w*(1-2*GLOW_MARGIN)
    : Math.random()*w;
  return{
    x:xPos,y:-10-Math.random()*50,
    speed:gl?1.0+Math.random()*0.6:5+Math.random()*3, // glowing drops faster
    length:gl?14+Math.random()*8:3+Math.random()*5,
    opacity:gl?1:0.15+Math.random()*0.20,
    isGlowing:gl,pulsePhase:Math.random()*Math.PI*2,
    width:gl?2.5:0.5+Math.random()*0.6,
    caught:false,fadeOut:1,
    drift:(Math.random()-0.5)*0.5,
  };
}

function mkFx(x,y){
  const ps=[];
  for(let i=0;i<14;i++){
    const a=(Math.PI*2*i)/14+Math.random()*0.3,s=2+Math.random()*3;
    ps.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s-1.5,life:1,size:1.5+Math.random()*3,
      color:Math.random()>0.5?"rgba(130,200,250,":"rgba(100,175,230,"});
  }
  return ps;
}

function mkRip(x,y){return{x,y,radius:3,opacity:0.45,speed:1};}

// === INPUT ===
function getPos(e){
  const r=cv.getBoundingClientRect();
  const sx=(cv.width/2)/r.width,sy=(cv.height/2)/r.height;
  const px=e.touches?e.touches[0].clientX:e.clientX;
  const py=e.touches?e.touches[0].clientY:e.clientY;
  return{x:(px-r.left)*sx,y:(py-r.top)*sy};
}

function tap(e){
  e.preventDefault();initAudio();

  if(gs.phase==="menu"){
    gs.phase="playing";gs.score=0;gs.timeLeft=DURATION;
    gs.drops=[];gs.catchPs=[];gs.ripples=[];
    gs.endT=0;gs.dimAlpha=0;gs.rainFaded=false;gs.rbPs=null;
    scheduleGlow();
    resetRain();lastTick=Date.now();return;
  }

  if(gs.phase==="quote"){
    gs.phase="menu";gs.score=0;
    gs.dimAlpha=0;gs.rainFaded=false;gs.rbPs=null;resetRain();return;
  }

  if(gs.phase!=="playing")return;

  const{x,y}=getPos(e);
  let best=Infinity,bi=-1;
  for(let i=0;i<gs.drops.length;i++){
    const d=gs.drops[i];if(!d.isGlowing||d.caught)continue;
    const dist=Math.hypot(x-d.x,y-d.y);
    if(dist<HIT_R&&dist<best){best=dist;bi=i;}
  }
  if(bi>=0){
    const d=gs.drops[bi];d.caught=true;gs.score++;
    gs.catchPs.push(...mkFx(d.x,d.y));
    gs.ripples.push(mkRip(d.x,d.y));chime();
    if(gs.score>=DROPS_TO_WIN){
      gs.phase="ending";gs.endT=0;
      gs.endQuote=QUOTES[Math.floor(Math.random()*QUOTES.length)];
      playEnd();
    }
  } else {
    gs.ripples.push(mkRip(x,y));
  }
}

cv.addEventListener("click",tap);
cv.addEventListener("touchstart",tap,{passive:false});

// === DRAW DROP ===
function drawDrop(d){
  c.save();
  if(d.isGlowing&&!d.caught){
    d.pulsePhase+=0.04;const p=0.6+Math.sin(d.pulsePhase)*0.4;
    // Blue-tinted white glow - soft oval
    const og=c.createRadialGradient(d.x,d.y,0,d.x,d.y,20);
    og.addColorStop(0,`rgba(200,220,255,${0.18*p})`);og.addColorStop(0.5,`rgba(170,200,245,${0.08*p})`);og.addColorStop(1,"rgba(150,180,230,0)");
    c.fillStyle=og;c.beginPath();c.ellipse(d.x,d.y,16,22,0,0,Math.PI*2);c.fill();
    // Inner glow - oval with blue tint
    const ig=c.createRadialGradient(d.x,d.y,0,d.x,d.y,8);
    ig.addColorStop(0,`rgba(230,240,255,${0.4*p})`);ig.addColorStop(1,`rgba(200,220,250,${0.15*p})`);
    c.fillStyle=ig;c.beginPath();c.ellipse(d.x,d.y,5,8,0,0,Math.PI*2);c.fill();
    // Oval drop shape
    c.fillStyle=`rgba(240,248,255,${0.75*p*d.fadeOut})`;
    c.beginPath();c.ellipse(d.x,d.y,3,5,0,0,Math.PI*2);c.fill();
    // Tiny bright center
    c.fillStyle=`rgba(255,255,255,${0.7*p*d.fadeOut})`;
    c.beginPath();c.ellipse(d.x,d.y,1.5,2.5,0,0,Math.PI*2);c.fill();
  } else {
    c.strokeStyle=`rgba(120,160,195,${d.opacity*d.fadeOut})`;c.lineWidth=d.width;c.lineCap="round";
    c.beginPath();c.moveTo(d.x+d.drift*5,d.y-d.length/2);c.lineTo(d.x,d.y+d.length/2);c.stroke();
  }
  c.restore();
}

// === MAIN LOOP ===
let lastTick=Date.now();

function loop(){
  const now=Date.now(),{w:cw,h:ch}=getSize();

  if(gs.phase==="playing"){
    const dt=now-lastTick;
    if(dt>=1000){
      gs.timeLeft=Math.max(0,gs.timeLeft-Math.floor(dt/1000));
      lastTick=now-(dt%1000);
      if(gs.timeLeft<=0){
        gs.phase="ending";gs.endT=0;
        gs.endQuote=QUOTES[Math.floor(Math.random()*QUOTES.length)];
        playEnd();
      }
    }
  }

  // === BG — rainy evening sky, much darker on top, lighter toward horizon ===
  const bg=c.createLinearGradient(0,0,0,ch);
  bg.addColorStop(0,"#0a0d14");bg.addColorStop(0.2,"#12161f");bg.addColorStop(0.4,"#1e2430");bg.addColorStop(0.55,"#2a3242");bg.addColorStop(0.7,"#3a4455");bg.addColorStop(1,"#4a5568");
  c.fillStyle=bg;c.fillRect(0,0,cw,ch);

  const isActive=gs.phase==="menu"||gs.phase==="playing"||gs.phase==="ending"||gs.phase==="quote";

  if(isActive){
    // Few static stars (no blinking) - brighter against dark sky
    c.fillStyle="rgba(220,225,240,0.6)";
    c.beginPath();c.arc(cw*0.12, ch*0.08, 1.2, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.35, ch*0.05, 1, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.58, ch*0.12, 1.3, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.78, ch*0.06, 1, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.92, ch*0.15, 1.1, 0, Math.PI*2);c.fill();
    c.fillStyle="rgba(200,210,230,0.45)";
    c.beginPath();c.arc(cw*0.25, ch*0.14, 0.9, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.68, ch*0.10, 0.8, 0, Math.PI*2);c.fill();
    c.beginPath();c.arc(cw*0.85, ch*0.03, 1.0, 0, Math.PI*2);c.fill();

    // Ocean scene
    drawOcean(cw,ch,now);

    // === RAIN ===
    const canSpawn=gs.phase==="playing"||gs.phase==="ending";
    const isMenu=gs.phase==="menu"||gs.phase==="quote";

    if(canSpawn&&now-gs.lastRain>RAIN_INT){
      for(let i=0;i<DENSE;i++) gs.drops.push(mkDrop(cw,ch,false));
      gs.lastRain=now;
    }
    if(isMenu&&now-gs.lastRain>120){
      for(let i=0;i<2;i++){const d=mkDrop(cw,ch,false);d.opacity=0.04+Math.random()*0.08;gs.drops.push(d);}
      gs.lastRain=now;
    }

    if(gs.phase==="playing"&&now>=gs.nextGlow){
      gs.drops.push(mkDrop(cw,ch,true));
      scheduleGlow();
    }

    // Remove oldest non-glowing drops if too many, but keep glowing drops
    if(gs.drops.length>800) {
      let removed = 0;
      for(let i=0;i<gs.drops.length && removed < 200;i++){
        if(!gs.drops[i].isGlowing){
          gs.drops.splice(i,1);
          removed++;
          i--;
        }
      }
    }

    for(let i=gs.drops.length-1;i>=0;i--){
      const d=gs.drops[i];d.y+=d.speed;d.x+=d.drift;
      if(d.caught){d.fadeOut-=0.08;if(d.fadeOut<=0){gs.drops.splice(i,1);continue;}}
      if(d.y>ch+20){gs.drops.splice(i,1);continue;}
      if((gs.phase==="ending"||gs.phase==="quote")&&d.isGlowing&&!d.caught){
        d.fadeOut-=0.02;if(d.fadeOut<=0){gs.drops.splice(i,1);continue;}
      }
      if(gs.phase==="ending"&&!d.isGlowing){d.opacity*=0.998;d.speed*=0.999;}
      drawDrop(d);
    }

    // Ripples
    for(let i=gs.ripples.length-1;i>=0;i--){
      const r=gs.ripples[i];r.radius+=r.speed;r.opacity-=0.01;
      if(r.opacity<=0){gs.ripples.splice(i,1);continue;}
      c.save();c.strokeStyle=`rgba(96,180,230,${r.opacity})`;c.lineWidth=1;
      c.beginPath();c.arc(r.x,r.y,r.radius,0,Math.PI*2);c.stroke();c.restore();
    }

    // Catch particles
    for(let i=gs.catchPs.length-1;i>=0;i--){
      const p=gs.catchPs[i];p.x+=p.vx;p.y+=p.vy;p.vy+=0.04;p.life-=0.016;
      if(p.life<=0){gs.catchPs.splice(i,1);continue;}
      c.save();c.globalAlpha=p.life;c.fillStyle=p.color+p.life+")";
      c.beginPath();c.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);c.fill();c.restore();
    }
  }

  // === PLAYING UI ===
  if(gs.phase==="playing"){
    const barW=5,barH=ch*0.6,barX=12,barY=(ch-barH)/2;
    const prog=Math.min(gs.score/DROPS_TO_WIN,1);
    c.fillStyle="rgba(255,255,255,0.06)";
    c.beginPath();c.roundRect(barX,barY,barW,barH,3);c.fill();
    if(prog>0){
      const fillH=barH*prog;
      const fg=c.createLinearGradient(0,barY+barH,0,barY+barH-fillH);
      fg.addColorStop(0,"rgba(70,170,230,0.4)");fg.addColorStop(1,"rgba(130,210,255,0.7)");
      c.fillStyle=fg;c.beginPath();c.roundRect(barX,barY+barH-fillH,barW,fillH,3);c.fill();
      c.shadowColor="rgba(70,170,230,0.35)";c.shadowBlur=6;
      c.beginPath();c.roundRect(barX,barY+barH-fillH,barW,fillH,3);c.fill();c.shadowBlur=0;
    }
    c.fillStyle="rgba(255,255,255,0.65)";c.font="600 13px 'Helvetica Neue',sans-serif";
    c.textAlign="center";c.fillText(`${gs.score}`,barX+barW/2,barY+barH+18);
  }

  // === MENU ===
  if(gs.phase==="menu"){
    gs.menuPulse+=0.018;
    c.fillStyle="rgba(5,10,25,0.45)";c.fillRect(0,ch*0.28,cw,ch*0.42);
    c.fillStyle="rgba(200,225,250,0.9)";c.font="600 32px 'Helvetica Neue',sans-serif";
    c.textAlign="center";c.fillText("raindrops",cw/2,ch/2-22);
    c.fillStyle=`rgba(130,200,245,${0.5+Math.sin(gs.menuPulse)*0.2})`;
    c.font="600 15px 'Helvetica Neue',sans-serif";c.fillText("tap to begin",cw/2,ch/2+10);
    c.fillStyle="rgba(130,200,245,0.4)";c.font="12px 'Helvetica Neue',sans-serif";
    c.fillText("catch the glowing drops",cw/2,ch/2+32);
    c.fillStyle="rgba(130,200,245,0.3)";c.font="11px 'Helvetica Neue',sans-serif";
    c.fillText("ocean",cw/2,ch/2+52);
  }

  // === ENDING — DARK BLUE TRANSITION ===
  if(gs.phase==="ending"){
    gs.endT+=0.005;
    const t=Math.min(gs.endT,1);

    if(!gs.rainFaded&&t>0.2){if(rainG&&actx)rainG.gain.linearRampToValueAtTime(0.05,actx.currentTime+4);gs.rainFaded=true;}

    // Fade to dark blue
    const r1=Math.floor(10+(20-10)*t),g1=Math.floor(16+(30-16)*t),b1=Math.floor(35+(55-35)*t);
    const r2=Math.floor(8+(15-8)*t),g2=Math.floor(18+(25-18)*t),b2=Math.floor(40+(50-40)*t);
    const tbg=c.createLinearGradient(0,0,0,ch);
    tbg.addColorStop(0,`rgb(${r1},${g1},${b1})`);tbg.addColorStop(1,`rgb(${r2},${g2},${b2})`);
    c.fillStyle=tbg;c.fillRect(0,0,cw,ch);

    for(let i=gs.drops.length-1;i>=0;i--){
      const d=gs.drops[i];d.opacity*=0.95;d.speed*=0.98;
      if(d.opacity<0.003){gs.drops.splice(i,1);continue;}
      c.save();c.strokeStyle=`rgba(160,180,200,${d.opacity})`;c.lineWidth=d.width;c.lineCap="round";
      c.beginPath();c.moveTo(d.x,d.y-d.length/2);c.lineTo(d.x,d.y+d.length/2);c.stroke();c.restore();
      d.y+=d.speed;
    }

    if(t>0.3){
      if(!gs.rbPs||gs.rbPs.length===0){
        gs.rbPs=[];
        // Shades of blue for ocean theme
        const cols=["#60a5fa","#3b82f6","#93c5fd","#2563eb","#7dd3fc","#38bdf8","#0ea5e9","#a5f3fc"];
        for(let i=0;i<100;i++)gs.rbPs.push({
          x:Math.random()*cw,y:Math.random()*ch,size:2+Math.random()*5,
          color:cols[Math.floor(Math.random()*cols.length)],
          speed:0.15+Math.random()*0.4,wobble:Math.random()*Math.PI*2,
          wobbleSpd:0.008+Math.random()*0.015,opacity:0,
          target:0.4+Math.random()*0.4,shape:Math.random()>0.5?"c":"d",
        });
      }
      const po=(t-0.3)/0.7;
      gs.rbPs.forEach(p=>{
        p.wobble+=p.wobbleSpd;p.y-=p.speed*0.3;p.x+=Math.sin(p.wobble)*0.3;
        if(p.y<-10)p.y=ch+10;
        c.save();c.globalAlpha=p.target*po*0.5;c.fillStyle=p.color;
        if(p.shape==="c"){c.beginPath();c.arc(p.x,p.y,p.size,0,Math.PI*2);c.fill();}
        else{c.translate(p.x,p.y);c.rotate(Math.PI/4);c.fillRect(-p.size/2,-p.size/2,p.size,p.size);}
        c.restore();
      });
    }

    if(gs.endT>1.3){gs.phase="quote";gs.quoteStartTime=Date.now();}
  }

  // === QUOTE SCREEN — DARK BLUE ===
  if(gs.phase==="quote"){
    // Dark blue background
    const rg=c.createLinearGradient(0,0,0,ch);
    rg.addColorStop(0,"#141e35");rg.addColorStop(0.5,"#0f1a2a");rg.addColorStop(1,"#0a1420");
    c.fillStyle=rg;c.fillRect(0,0,cw,ch);

    // Floating particles - no rainbow
    if(gs.rbPs)gs.rbPs.forEach(p=>{
      p.wobble+=p.wobbleSpd;p.y-=p.speed*0.2;p.x+=Math.sin(p.wobble)*0.25;
      if(p.opacity<p.target)p.opacity+=0.006;
      if(p.y<-10){p.y=ch+10;p.x=Math.random()*cw;}
      c.save();c.globalAlpha=p.opacity*0.7;c.fillStyle=p.color;
      if(p.shape==="c"){c.beginPath();c.arc(p.x,p.y,p.size,0,Math.PI*2);c.fill();}
      else{c.translate(p.x,p.y);c.rotate(Math.PI/4);c.fillRect(-p.size/2,-p.size/2,p.size,p.size);}
      c.restore();
    });

    // Quote - fades out after 10 seconds
    const quoteAge = (Date.now() - gs.quoteStartTime) / 1000;
    const quoteFade = quoteAge < 8 ? 1 : Math.max(0, 1 - (quoteAge - 8) / 2);
    
    if(quoteFade > 0){
      c.save();
      c.globalAlpha = quoteFade;
      const words=gs.endQuote.split(" ");
      let lines=[],line="";
      words.forEach(w=>{const test=line?line+" "+w:w;if(test.length>22){lines.push(line);line=w;}else line=test;});
      if(line)lines.push(line);
      const lh=32,qtH=lines.length*lh+36,qtW=cw*0.85,qtX=(cw-qtW)/2,qtY=ch/2-qtH/2-20;
      // Dark semi-transparent box
      c.fillStyle="rgba(30,45,65,0.6)";
      c.beginPath();c.roundRect(qtX,qtY,qtW,qtH,14);c.fill();
      // Light text
      c.fillStyle="rgba(220,225,235,0.95)";
      c.font="italic 600 22px 'Helvetica Neue',sans-serif";
      c.textAlign="center";
      lines.forEach((l,i)=>c.fillText(l,cw/2,qtY+28+i*lh));
      c.restore();
    }

    // Tap button - always visible
    const btnW=140,btnH=34,btnX=(cw-btnW)/2,btnY=ch-55;
    c.fillStyle="rgba(40,60,90,0.5)";
    c.beginPath();c.roundRect(btnX,btnY,btnW,btnH,17);c.fill();
    c.fillStyle="rgba(200,210,225,0.8)";c.font="600 13px 'Helvetica Neue',sans-serif";
    c.textAlign="center";c.fillText("tap to continue",cw/2,btnY+btnH/2+4);
  }

  requestAnimationFrame(loop);
}

scheduleGlow();
requestAnimationFrame(loop);
</script>
</body>
</html>
