<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Raindrops — A moment in time</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;}
body{background:#020412;display:flex;flex-direction:column;align-items:center;justify-content:center;
min-height:100vh;min-height:100dvh;font-family:'Helvetica Neue',-apple-system,sans-serif;
user-select:none;-webkit-user-select:none;touch-action:none;overflow:hidden;}
canvas{border-radius:12px;cursor:pointer;touch-action:none;box-shadow:0 0 60px rgba(80,100,180,0.04);}
.sub{color:rgba(255,255,255,0.25);font-size:12px;margin-top:10px;letter-spacing:2px;text-align:center;}
</style>
</head>
<body>
<canvas id="g"></canvas>
<p class="sub">RAINDROPS — A moment in time</p>
<script>
// === AUDIO — space.mp3 crossfade loop ===
let actx=null,started=false;
let spaceBuffer=null,spaceGain=null;
let spaceState={src:null,timer:null,startAt:0};
const SPACE_XFADE=4.0;

function scheduleSpaceXf(buf,gainNode,state){
  if(!actx||!buf||!gainNode)return;
  const dur=buf.duration;
  const src=actx.createBufferSource();src.buffer=buf;
  const srcG=actx.createGain();
  srcG.gain.setValueAtTime(0,state.startAt);
  srcG.gain.linearRampToValueAtTime(1,state.startAt+SPACE_XFADE);
  const fadeOutAt=state.startAt+dur-SPACE_XFADE;
  srcG.gain.setValueAtTime(1,fadeOutAt);
  srcG.gain.linearRampToValueAtTime(0,state.startAt+dur);
  src.connect(srcG);srcG.connect(gainNode);
  src.start(state.startAt);src.stop(state.startAt+dur);
  state.src=src;
  const delay=Math.max(0,(fadeOutAt-actx.currentTime)*1000);
  state.timer=setTimeout(()=>{state.startAt=actx.currentTime;scheduleSpaceXf(buf,gainNode,state);},delay);
}

function initAudio(){
  if(started)return;
  try{
    actx=new(window.AudioContext||window.webkitAudioContext)();
    spaceGain=actx.createGain();spaceGain.gain.value=0.45;spaceGain.connect(actx.destination);
    started=true;
    fetch("audio/space.mp3")
      .then(r=>{if(!r.ok)throw new Error();return r.arrayBuffer();})
      .then(ab=>actx.decodeAudioData(ab))
      .then(buf=>{spaceBuffer=buf;spaceState.startAt=actx.currentTime;scheduleSpaceXf(buf,spaceGain,spaceState);})
      .catch(()=>{
        // Fallback: minimal ambient drone
        const sr=actx.sampleRate,len=sr*4;
        const buf1=actx.createBuffer(2,len,sr);
        for(let ch=0;ch<2;ch++){const d=buf1.getChannelData(ch);let lx=0;
          for(let i=0;i<len;i++){const w=Math.random()*2-1;d[i]=(lx+(0.01*w))/1.01;lx=d[i];d[i]*=1.5;}}
        const s1=actx.createBufferSource();s1.buffer=buf1;s1.loop=true;
        const f1=actx.createBiquadFilter();f1.type="lowpass";f1.frequency.value=160;
        const g1=actx.createGain();g1.gain.value=0.03;
        s1.connect(f1);f1.connect(g1);g1.connect(actx.destination);s1.start();
        const dr=actx.createOscillator();dr.type="sine";dr.frequency.value=55;
        const dg=actx.createGain();dg.gain.value=0.012;
        dr.connect(dg);dg.connect(actx.destination);dr.start();
      });
  }catch(e){}
}

// Celestial chime — ethereal, spacey
function chime(x,y,cw,ch){
  if(!actx)return;
  // Soft bloop — sine sweep down, quick pop envelope
  const f=180+Math.random()*120; // low-mid range for a soft pop feel
  const o=actx.createOscillator(),g=actx.createGain();
  o.type="sine";
  o.frequency.setValueAtTime(f*1.6,actx.currentTime);
  o.frequency.exponentialRampToValueAtTime(f,actx.currentTime+0.06);
  g.gain.setValueAtTime(0.0,actx.currentTime);
  g.gain.linearRampToValueAtTime(0.045,actx.currentTime+0.008);
  g.gain.exponentialRampToValueAtTime(0.012,actx.currentTime+0.12);
  g.gain.exponentialRampToValueAtTime(0.001,actx.currentTime+0.4);
  o.connect(g);g.connect(actx.destination);o.start();o.stop(actx.currentTime+0.4);
  // Tiny sub thump for body
  const o2=actx.createOscillator(),g2=actx.createGain();
  o2.type="sine";o2.frequency.value=f*0.5;
  g2.gain.setValueAtTime(0.025,actx.currentTime);
  g2.gain.exponentialRampToValueAtTime(0.001,actx.currentTime+0.18);
  o2.connect(g2);g2.connect(actx.destination);o2.start();o2.stop(actx.currentTime+0.18);
}

// === CANVAS ===
const cv=document.getElementById("g"),c=cv.getContext("2d");
function getSize(){
  const mw=Math.min(window.innerWidth*0.98,700);
  const mh=(window.innerHeight||document.documentElement.clientHeight)*0.90;
  let w=mw,h=w/(16/9);if(h>mh){h=mh;w=h*(16/9);}if(w>mw){w=mw;h=w/(16/9);}
  return{w:Math.floor(w),h:Math.floor(h)};
}
function resize(){const{w,h}=getSize();cv.width=w*2;cv.height=h*2;cv.style.width=w+"px";cv.style.height=h+"px";c.setTransform(2,0,0,2,0,0);}
resize();window.addEventListener("resize",resize);

// === STARS ===
function buildStars(w,h){
  const stars=[];
  // Tiny distant stars — many, very faint
  for(let i=0;i<130;i++){
    stars.push({
      x:Math.random()*w, y:Math.random()*h*0.78,
      size:0.25+Math.random()*0.45,
      baseAlpha:0.06+Math.random()*0.16,
      twinkleSpeed:0.00008+Math.random()*0.00025,
      twinklePhase:Math.random()*Math.PI*2, warm:false,
    });
  }
  // Medium stars
  for(let i=0;i<50;i++){
    stars.push({
      x:Math.random()*w, y:Math.random()*h*0.78,
      size:0.55+Math.random()*0.9,
      baseAlpha:0.18+Math.random()*0.28,
      twinkleSpeed:0.00005+Math.random()*0.00015,
      twinklePhase:Math.random()*Math.PI*2,
      warm:Math.random()>0.88,
    });
  }
  // Bright prominent stars — just a few
  for(let i=0;i<10;i++){
    stars.push({
      x:Math.random()*w, y:Math.random()*h*0.78,
      size:1.3+Math.random()*1.0,
      baseAlpha:0.5+Math.random()*0.3,
      twinkleSpeed:0.00003+Math.random()*0.0001,
      twinklePhase:Math.random()*Math.PI*2,
      warm:Math.random()>0.65,
    });
  }
  return stars;
}
let stars=null;

// === SHOOTING STARS ===
const shooters=[];
const ripples=[];
const SHOOT_MIN=4000,SHOOT_MAX=9000;
let nextShoot=Date.now()+2000;

function scheduleShoot(){
  nextShoot=Date.now()+SHOOT_MIN+Math.random()*(SHOOT_MAX-SHOOT_MIN);
}

function spawnShooter(w,h){
  // Start from upper portion, travel diagonally
  const startX=Math.random()*w*0.8;
  const startY=Math.random()*h*0.4;
  const angle=0.3+Math.random()*0.6; // roughly diagonal downward-right
  const speed=0.5+Math.random()*0.7;
  shooters.push({
    x:startX,y:startY,
    vx:Math.cos(angle)*speed,
    vy:Math.sin(angle)*speed,
    life:1,
    length:20+Math.random()*30,
    caught:false,fadeOut:1,
    trail:[],
  });
}

// === LUNAR SURFACE ===
function buildCraters(w,h){
  const craters=[];
  for(let i=0;i<12;i++){
    craters.push({
      x:Math.random()*w,
      y:h*0.78+Math.random()*h*0.2,
      r:5+Math.random()*20,
      depth:0.02+Math.random()*0.03,
    });
  }
  return craters;
}
let craters=null;

function drawMoon(w,h){
  if(!craters)craters=buildCraters(w,h);
  const surfaceY=h*0.78;

  // Curved horizon — subtle arc
  c.save();
  c.fillStyle="rgba(18,18,24,1)";
  c.beginPath();
  c.moveTo(0,h);
  c.lineTo(0,surfaceY+10);
  // Gentle curve across
  c.quadraticCurveTo(w*0.25,surfaceY-5,w*0.5,surfaceY);
  c.quadraticCurveTo(w*0.75,surfaceY+5,w,surfaceY-2);
  c.lineTo(w,h);
  c.closePath();
  c.fill();

  // Surface texture gradient
  const surfGrad=c.createLinearGradient(0,surfaceY-10,0,h);
  surfGrad.addColorStop(0,"rgba(30,30,40,1)");
  surfGrad.addColorStop(0.3,"rgba(22,22,30,1)");
  surfGrad.addColorStop(1,"rgba(14,14,20,1)");
  c.fillStyle=surfGrad;
  c.beginPath();
  c.moveTo(0,h);
  c.lineTo(0,surfaceY+10);
  c.quadraticCurveTo(w*0.25,surfaceY-5,w*0.5,surfaceY);
  c.quadraticCurveTo(w*0.75,surfaceY+5,w,surfaceY-2);
  c.lineTo(w,h);
  c.closePath();
  c.fill();

  // Craters
  craters.forEach(cr=>{
    // Shadow
    c.fillStyle=`rgba(10,10,16,${cr.depth})`;
    c.beginPath();c.ellipse(cr.x,cr.y,cr.r,cr.r*0.3,0,0,Math.PI*2);c.fill();
    // Rim highlight
    c.strokeStyle=`rgba(45,45,58,${cr.depth*1.5})`;
    c.lineWidth=0.5;
    c.beginPath();c.ellipse(cr.x,cr.y,cr.r,cr.r*0.3,0,Math.PI*1.1,Math.PI*1.9);c.stroke();
  });
  c.restore();

  // Horizon glow — very subtle
  const hGlow=c.createLinearGradient(0,surfaceY-20,0,surfaceY+5);
  hGlow.addColorStop(0,"rgba(60,65,90,0)");
  hGlow.addColorStop(0.7,"rgba(60,65,90,0.04)");
  hGlow.addColorStop(1,"rgba(60,65,90,0)");
  c.fillStyle=hGlow;c.fillRect(0,surfaceY-20,w,25);
}

// === EARTH — matches main screen style ===
function drawEarth(w,h,t){
  const ex=w*0.22,ey=h*0.3,er=22;
  const rot=t*0.000012;

  // Outer atmospheric glow
  const halo=c.createRadialGradient(ex,ey,er*0.9,ex,ey,er*4);
  halo.addColorStop(0,"rgba(70,150,240,0.20)");
  halo.addColorStop(0.3,"rgba(50,120,210,0.08)");
  halo.addColorStop(0.65,"rgba(40,100,180,0.03)");
  halo.addColorStop(1,"rgba(40,100,180,0)");
  c.fillStyle=halo;c.beginPath();c.arc(ex,ey,er*4,0,Math.PI*2);c.fill();

  // Clipped earth body
  c.save();
  c.beginPath();c.arc(ex,ey,er,0,Math.PI*2);c.clip();

  // Ocean
  const ocean=c.createRadialGradient(ex-er*0.25,ey-er*0.25,0,ex,ey,er);
  ocean.addColorStop(0,"rgb(55,135,215)");
  ocean.addColorStop(0.45,"rgb(35,105,188)");
  ocean.addColorStop(0.8,"rgb(20,72,155)");
  ocean.addColorStop(1,"rgb(12,50,115)");
  c.fillStyle=ocean;c.fillRect(ex-er,ey-er,er*2,er*2);

  // Main landmass — one dominant green shape (like screenshot)
  c.globalAlpha=1;
  c.fillStyle="rgb(48,118,62)";
  c.beginPath();
  c.ellipse(ex+er*0.18+Math.sin(rot)*1.5, ey+er*0.02, er*0.36, er*0.52, 0.35+rot*0.08, 0, Math.PI*2);
  c.fill();
  c.fillStyle="rgb(38,105,52)";
  c.beginPath();
  c.ellipse(ex+er*0.05+Math.sin(rot)*1.5, ey-er*0.18, er*0.20, er*0.28, 0.8+rot*0.08, 0, Math.PI*2);
  c.fill();
  // Small secondary landmass
  c.fillStyle="rgb(55,125,68)";
  c.beginPath();
  c.ellipse(ex-er*0.28+Math.cos(rot)*1.5, ey+er*0.32, er*0.18, er*0.22, -0.25+rot*0.08, 0, Math.PI*2);
  c.fill();

  // Cloud wisps — bright white like screenshot
  c.fillStyle="rgb(242,248,255)";
  c.globalAlpha=0.88;
  c.beginPath();
  c.ellipse(ex-er*0.05+Math.sin(rot*1.8)*1.2, ey-er*0.58, er*0.52, er*0.12, 0.08, 0, Math.PI*2);
  c.fill();
  c.globalAlpha=0.65;
  c.beginPath();
  c.ellipse(ex+er*0.32+Math.cos(rot*1.8)*1.2, ey+er*0.22, er*0.32, er*0.09, -0.15, 0, Math.PI*2);
  c.fill();
  c.globalAlpha=0.5;
  c.beginPath();
  c.ellipse(ex-er*0.38, ey-er*0.15, er*0.20, er*0.07, 0.25, 0, Math.PI*2);
  c.fill();

  // Dark limb vignette
  const limb=c.createRadialGradient(ex,ey,er*0.65,ex,ey,er);
  limb.addColorStop(0,"rgba(0,0,0,0)");
  limb.addColorStop(0.82,"rgba(0,0,0,0)");
  limb.addColorStop(1,"rgba(0,8,25,0.55)");
  c.globalAlpha=1;c.fillStyle=limb;c.fillRect(ex-er,ey-er,er*2,er*2);

  c.restore();

  // Bright rim highlight (lit from upper-left like screenshot)
  c.save();
  c.globalAlpha=0.4;
  c.strokeStyle="rgba(170,220,255,1)";
  c.lineWidth=1.2;
  c.beginPath();c.arc(ex,ey,er,Math.PI*1.05,Math.PI*1.72);c.stroke();
  c.restore();
}

// === STATE ===
let phase="sanctuary"; // always sanctuary, no menu needed... or maybe a gentle entrance

// Button state
const btn={w:52,h:24};

function getBtnPos(cw,ch){
  return{x:cw-btn.w-14,y:ch-btn.h-14};
}

// === INPUT ===
function getPos(e){
  const r=cv.getBoundingClientRect();
  const sx=(cv.width/2)/r.width,sy=(cv.height/2)/r.height;
  const px=e.touches?e.touches[0].clientX:e.clientX;
  const py=e.touches?e.touches[0].clientY:e.clientY;
  return{x:(px-r.left)*sx,y:(py-r.top)*sy};
}

function tap(e){
  e.preventDefault();initAudio();
  const{w:cw,h:ch}=getSize();
  const{x,y}=getPos(e);

  // Check "take me home" button
  const bp=getBtnPos(cw,ch);
  if(x>=bp.x&&x<=bp.x+btn.w&&y>=bp.y&&y<=bp.y+btn.h){
    // Navigate back — or just reload to show they can leave
    window.location.href="index.html";
    return;
  }

  // Check shooting star catch
  let caught=false;
  for(let i=0;i<shooters.length;i++){
    const s=shooters[i];
    if(s.caught)continue;
    const dist=Math.hypot(x-s.x,y-s.y);
    if(dist<50){
      s.caught=true;caught=true;
      chime(s.x,s.y,cw,ch);
      // Glow ripple
      ripples.push({x:s.x,y:s.y,radius:5,opacity:0.6,speed:0.8,
        color:"rgba(200,210,255,"});
      ripples.push({x:s.x,y:s.y,radius:3,opacity:0.3,speed:1.2,
        color:"rgba(255,230,200,"});
      break;
    }
  }

  // Tap anywhere else — subtle ripple
  if(!caught){
    ripples.push({x,y,radius:3,opacity:0.2,speed:0.6,
      color:"rgba(150,160,200,"});
  }
}

cv.addEventListener("click",tap);
cv.addEventListener("touchstart",tap,{passive:false});

// === MAIN LOOP ===
let fadeIn=0;

function loop(){
  const now=Date.now(),{w:cw,h:ch}=getSize();

  // Gentle fade in
  if(fadeIn<1)fadeIn+=0.005;

  // === BACKGROUND — deep indigo space ===
  const bg=c.createLinearGradient(0,0,0,ch);
  bg.addColorStop(0,"#010109");
  bg.addColorStop(0.2,"#02030e");
  bg.addColorStop(0.45,"#040716");
  bg.addColorStop(0.68,"#090e24");
  bg.addColorStop(0.85,"#0f1530");
  bg.addColorStop(1,"#16213a");
  c.fillStyle=bg;c.fillRect(0,0,cw,ch);

  c.save();
  c.globalAlpha=fadeIn;

  // === STARS ===
  if(!stars)stars=buildStars(cw,ch);
  stars.forEach(s=>{
    const twinkle=s.baseAlpha*(0.5+0.5*Math.sin(now*s.twinkleSpeed+s.twinklePhase));
    if(s.warm){
      c.fillStyle=`rgba(255,220,180,${twinkle})`;
    } else {
      c.fillStyle=`rgba(220,225,255,${twinkle})`;
    }
    c.beginPath();c.arc(s.x,s.y,s.size,0,Math.PI*2);c.fill();
  });

  // === EARTH ===
  drawEarth(cw,ch,now);

  // === MOON SURFACE ===
  drawMoon(cw,ch);

  // === SHOOTING STARS ===
  // Spawn
  if(now>=nextShoot){
    spawnShooter(cw,ch);
    scheduleShoot();
  }

  // Update & draw
  for(let i=shooters.length-1;i>=0;i--){
    const s=shooters[i];
    if(s.caught){
      s.fadeOut-=0.03;
      if(s.fadeOut<=0){shooters.splice(i,1);continue;}
      // Expanding glow on catch
      c.save();
      const cg=c.createRadialGradient(s.x,s.y,0,s.x,s.y,30*(1-s.fadeOut));
      cg.addColorStop(0,`rgba(220,210,255,${0.3*s.fadeOut})`);
      cg.addColorStop(1,"rgba(220,210,255,0)");
      c.fillStyle=cg;c.beginPath();c.arc(s.x,s.y,30*(1-s.fadeOut),0,Math.PI*2);c.fill();
      c.restore();
      continue;
    }

    s.x+=s.vx;s.y+=s.vy;
    s.life-=0.002;

    // Trail
    s.trail.push({x:s.x,y:s.y,alpha:0.6});
    if(s.trail.length>20)s.trail.shift();

    if(s.life<=0||s.x>cw+50||s.y>ch*0.75){
      shooters.splice(i,1);continue;
    }

    // Draw trail
    for(let t=0;t<s.trail.length;t++){
      const tp=s.trail[t];
      tp.alpha*=0.88;
      const trailW=1.5*(t/s.trail.length);
      c.strokeStyle=`rgba(220,215,255,${tp.alpha*s.life})`;
      c.lineWidth=trailW;c.lineCap="round";
      if(t>0){
        c.beginPath();
        c.moveTo(s.trail[t-1].x,s.trail[t-1].y);
        c.lineTo(tp.x,tp.y);
        c.stroke();
      }
    }

    // Head glow
    const hg=c.createRadialGradient(s.x,s.y,0,s.x,s.y,10);
    hg.addColorStop(0,`rgba(240,235,255,${0.5*s.life})`);
    hg.addColorStop(0.5,`rgba(200,200,240,${0.15*s.life})`);
    hg.addColorStop(1,"rgba(200,200,240,0)");
    c.fillStyle=hg;c.beginPath();c.arc(s.x,s.y,10,0,Math.PI*2);c.fill();

    // Bright core
    c.fillStyle=`rgba(255,255,255,${0.8*s.life})`;
    c.beginPath();c.arc(s.x,s.y,1.5,0,Math.PI*2);c.fill();
  }

  // === RIPPLES ===
  for(let i=ripples.length-1;i>=0;i--){
    const r=ripples[i];
    r.radius+=r.speed;r.opacity-=0.008;
    if(r.opacity<=0){ripples.splice(i,1);continue;}
    c.save();c.strokeStyle=r.color+r.opacity+")";c.lineWidth=1;
    c.beginPath();c.arc(r.x,r.y,r.radius,0,Math.PI*2);c.stroke();c.restore();
  }

  // === HOME — small corner label ===
  const bp=getBtnPos(cw,ch);
  c.save();
  const _tw=c.measureText("home").width;
  const _px=cw-14,_py=ch-16,_pad=6;
  c.fillStyle="rgba(8,14,40,0.72)";
  c.beginPath();c.roundRect(_px-_tw-_pad,_py-13,_tw+_pad*2,20,6);c.fill();
  c.fillStyle="rgba(200,218,255,0.92)";
  c.font="500 11px 'Helvetica Neue',sans-serif";
  c.textAlign="right";
  c.fillText("home",_px,_py);
  c.restore();

  c.restore();

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
